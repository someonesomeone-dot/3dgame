<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Shooting Game</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #instructions {
      position: absolute;
      top: 50%;
      width: 100%;
      text-align: center;
      color: #fff;
      font-family: Arial, sans-serif;
      font-size: 24px;
      user-select: none;
      z-index: 1;
    }
  </style>
</head>
<body>
  <div id="instructions">
    Click to play (WASD to move, mouse to look, left-click to shoot)
  </div>
  <!-- Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
  <!-- PointerLockControls from Three.js examples -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/controls/PointerLockControls.js"></script>
  <script>
    let camera, scene, renderer, controls;
    let objects = []; // Will store target objects
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    init();
    animate();

    function init() {
      // Create scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x202020);

      // Create camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 1000);
      camera.position.y = 10; // Eye level

      // Create renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Add basic ambient and directional light
      scene.add(new THREE.AmbientLight(0xffffff, 0.3));
      const light = new THREE.DirectionalLight(0xffffff, 0.8);
      light.position.set(1, 1, 1).normalize();
      scene.add(light);

      // Create ground plane
      const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
      const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Add some target boxes
      const boxGeometry = new THREE.BoxGeometry(4, 4, 4);
      const boxMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
      for (let i = 0; i < 10; i++) {
        const box = new THREE.Mesh(boxGeometry, boxMaterial);
        // Place targets randomly ahead of the player
        box.position.set(Math.random() * 100 - 50, 2, Math.random() * -100 - 20);
        scene.add(box);
        objects.push(box);
      }

      // Set up pointer lock controls for first-person movement
      controls = new THREE.PointerLockControls(camera, document.body);

      const instructions = document.getElementById('instructions');
      instructions.addEventListener('click', () => {
        controls.lock();
      });

      controls.addEventListener('lock', () => {
        instructions.style.display = 'none';
      });

      controls.addEventListener('unlock', () => {
        instructions.style.display = '';
      });

      scene.add(controls.getObject());

      // Movement variables
      const move = { forward: false, backward: false, left: false, right: false };
      const velocity = new THREE.Vector3();

      // Listen for keyboard events
      const onKeyDown = (event) => {
        switch(event.code) {
          case 'KeyW': move.forward = true; break;
          case 'KeyS': move.backward = true; break;
          case 'KeyA': move.left = true; break;
          case 'KeyD': move.right = true; break;
        }
      };
      const onKeyUp = (event) => {
        switch(event.code) {
          case 'KeyW': move.forward = false; break;
          case 'KeyS': move.backward = false; break;
          case 'KeyA': move.left = false; break;
          case 'KeyD': move.right = false; break;
        }
      };
      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);

      // Shooting mechanism: raycast on mouse click.
      document.addEventListener('mousedown', (event) => {
        if (event.button === 0 && controls.isLocked === true) { // left click
          // Set up ray from camera
          raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
          const intersects = raycaster.intersectObjects(objects);
          if (intersects.length > 0) {
            const target = intersects[0].object;
            scene.remove(target);
            objects = objects.filter(obj => obj !== target);
            console.log('Target hit!');
          }
        }
      });

      // Animation update for movement
      const clock = new THREE.Clock();
      function updateMovement() {
        const delta = clock.getDelta();
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;
        const speed = 50.0;

        if (move.forward) velocity.z -= speed * delta;
        if (move.backward) velocity.z += speed * delta;
        if (move.left) velocity.x -= speed * delta;
        if (move.right) velocity.x += speed * delta;

        controls.moveRight(velocity.x * delta);
        controls.moveForward(velocity.z * delta);
      }

      // Include updateMovement in the animation loop
      renderer.setAnimationLoop(() => {
        updateMovement();
        renderer.render(scene, camera);
      });

      // Adjust scene on window resize.
      window.addEventListener('resize', onWindowResize);
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    }

    function animate() {
      // The rendering and movement update are handled in renderer.setAnimationLoop in init().
    }
  </script>
</body>
</html>
